---
layout: post
title: "C#'da libclang kullanÄ±mÄ±"
date: 2025-03-22
categories: [yazÄ±lÄ±m, csharp]
tags: [libclang, C#, parser, clang, interop]
---

C# dilinde `libclang` kullanarak C++ kodlarÄ±nÄ± ayrÄ±ÅŸtÄ±rmak mÃ¼mkÃ¼n mÃ¼?  
Bu yazÄ±da `libclang` kÃ¼tÃ¼phanesini C# ile nasÄ±l kullanabileceÄŸimizi adÄ±m adÄ±m gÃ¶stereceÄŸim.

Hadi baÅŸlayalÄ±m! ğŸš€

OlabildiÄŸince Ã§ok tipin olduÄŸu yapabildiÄŸimiz kadar karmaÅŸÄ±k bir struct yapalÄ±m. 
AÅŸaÄŸÄ±daki struct hem baÅŸka bir structtan tÃ¼rÃ¼yor ve tÃ¼rediÄŸi struct'Ä±n bazÄ± elemanlarÄ±nÄ± ilkliyor.
hem iÃ§erisinde bir enum tutuyor, hem de yine bir eleman olarak bir namespace iÃ§erisinde struct barÄ±ndÄ±rÄ±yor.


```c++
#pragma once

#include <cstdint>

#pragma pack(push, 1)

struct STestBase
{
  uint16_t Base0;
  uint16_t Base1;
};

enum class ETest
{
  Test0,
  Test1,
  Test2,
};

namespace NTest
{
  struct STest
  {
    float Test1;
    double Test2;
  };
}

struct STest : STestBase
{
  uint64_t Test0;  
  uint32_t Test1;
  uint16_t Test2;
  uint8_t Test3;

  int64_t Test4;
  int32_t Test5;
  int16_t Test6;
  int8_t Test7;

  float Test8;
  double Test9;

  uint8_t Test10[10];
	
  bool Test11;
  char Test12;

  NTest::STest Test13;
};

#pragma pack(pop)
```

Bu dosyayÄ± cpp elemanlarÄ±na ayrÄ±ÅŸtÄ±rmak iÃ§in Tools â†’ Nuget Package Manager â†’ Manage Nuget Packages for Solutions 'a gidip
ClangSharp paketini yÃ¼klemeliyiz. Bu yazÄ±nÄ±n yazÄ±ldÄ±ÄŸÄ± tarihte en gÃ¼ncel ve kararlÄ± sÃ¼rÃ¼m 18.1.0.3'tÃ¼r.

<img src="{{site.baseurl | prepend: site.url}}/assets/images/clangsharp_ver.PNG" alt="ClangSharp Versiyon" />

Bu yÃ¼klemeyi yaptÄ±ktan sonra paketin iÃ§erisindeki:
1. ClangSharp.dll
2. ClangSharp.Interop.dll
3. libclang.dll
4. libClangSharp.dll kÃ¼tÃ¼phaneleri exe dosyasÄ±nÄ±n yanÄ±na kopyalanmalÄ±dÄ±r.

CXIndex, Clang kÃ¼tÃ¼phanesinde bir analiz "oturumunu" temsil eder. 
Bu nesne oluÅŸturulmadan Clang ile hiÃ§bir dosya analiz edilemez.
Clang motorunu kullanmak iÃ§in gerekli olan altyapÄ±yÄ± hazÄ±rlar.
Bu baÄŸlam Ã¼zerinden bir veya daha fazla dosya ayrÄ±ÅŸtÄ±rÄ±labilir.
Ã‡oÄŸu durumda tek bir CXIndex yeterlidir. Ancak:
* Paralel olarak birden fazla analiz yapÄ±lacaksa,
* Ya da birbirinden baÄŸÄ±msÄ±z Ã§eviri birimleri iÅŸlenecekse birden fazla CXIndex kullanÄ±labilir.

```csharp
var index = CXIndex.Create();
```
 CXTranslationUnit.Parse iÅŸlevini bir cpp dosyasÄ± iÃ§in Ã§aÄŸÄ±rarak bu dosya iÃ§in Ã§eviri birimi(ing. translation unit) Ã¼retir.
 Bu birim kodda bir Soyut SÃ¶zdizimi AÄŸacÄ±(ing. AST) olarak temsil edilir.
 
 Not: Ã‡eviri birimi bir cpp veya hpp dosyasÄ±nÄ±n Ã¶n iÅŸlemciden geÃ§tikten sonraki haline denir. Derleyici bu birimi girdi olarak alÄ±r ve 
 Ã§Ä±ktÄ± olarak obje dosyasÄ± Ã¼retir.
```csharp
var tu = CXTranslationUnit.Parse(index, "filePath.hpp",
    commandLineArgs: Array.Empty<string>(),
    unsavedFiles: Array.Empty<CXUnsavedFile>(),
    options: CXTranslationUnit_Flags.CXTranslationUnit_None);
```

Ã‡eviri birimi Ã¼retildikten sonra 
```csharp
CXCursorVisitor visitor = (CXCursor c, CXCursor parent, void* data) =>
{
    if (c.Kind == CXCursorKind.CXCursor_StructDecl)
    {
        Debug.WriteLine($"StructDecl: {c.Spelling}");

        var baseSpecCount = c.NumBases;
        for (uint i = 0; i < baseSpecCount; i++)
        {
            var baseType = c.GetBase(i);
            Debug.WriteLine($"BaseSpecifier: {baseType.Spelling}");
        }
    }

    if (c.Kind == CXCursorKind.CXCursor_FieldDecl)
    {
        var type = c.Type;
        Debug.WriteLine($"FieldDecl: {c.Spelling} (type: {type.Spelling})");
    }

    return CXChildVisitResult.CXChildVisit_Recurse;
};
```

```csharp
trUnit.Cursor.VisitChildren(visitor, (CXClientData)null);
```

```csharp
trUnit.Dispose();
```

```csharp
index.Dispose();
```